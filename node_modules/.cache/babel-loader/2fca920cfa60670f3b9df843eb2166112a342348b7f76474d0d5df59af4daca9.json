{"ast":null,"code":"import { ref, getCurrentInstance, inject, computed, provide, unref } from 'vue';\nimport '../../tokens/index.mjs';\nimport '../../utils/index.mjs';\nimport { configProviderContextKey } from '../../tokens/config-provider.mjs';\nimport { debugWarn } from '../../utils/error.mjs';\nimport { keysOf } from '../../utils/objects.mjs';\nconst globalConfig = ref();\nfunction useGlobalConfig(key, defaultValue = void 0) {\n  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;\n  if (key) {\n    return computed(() => {\n      var _a, _b;\n      return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;\n    });\n  } else {\n    return config;\n  }\n}\nconst provideGlobalConfig = (config, app, global = false) => {\n  var _a;\n  const inSetup = !!getCurrentInstance();\n  const oldConfig = inSetup ? useGlobalConfig() : void 0;\n  const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? provide : void 0;\n  if (!provideFn) {\n    debugWarn(\"provideGlobalConfig\", \"provideGlobalConfig() can only be used inside setup().\");\n    return;\n  }\n  const context = computed(() => {\n    const cfg = unref(config);\n    if (!(oldConfig == null ? void 0 : oldConfig.value)) return cfg;\n    return mergeConfig(oldConfig.value, cfg);\n  });\n  provideFn(configProviderContextKey, context);\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value;\n  }\n  return context;\n};\nconst mergeConfig = (a, b) => {\n  var _a;\n  const keys = [... /* @__PURE__ */new Set([...keysOf(a), ...keysOf(b)])];\n  const obj = {};\n  for (const key of keys) {\n    obj[key] = (_a = b[key]) != null ? _a : a[key];\n  }\n  return obj;\n};\nexport { provideGlobalConfig, useGlobalConfig };","map":{"version":3,"mappings":";;;;;;AAGA,MAAMA,YAAY,GAAGC,GAAG,EAAE;AACnB,SAASC,eAAe,CAACC,GAAG,EAAEC,YAAY,GAAG,KAAK,CAAC,EAAE;EAC1D,MAAMC,MAAM,GAAGC,kBAAkB,EAAE,GAAGC,MAAM,CAACC,wBAAwB,EAAER,YAAY,CAAC,GAAGA,YAAY;EACnG,IAAIG,GAAG,EAAE;IACP,OAAOM,QAAQ,CAAC,MAAM;MACpB,IAAIC,EAAE,EAAEC,EAAE;MACV,OAAO,CAACA,EAAE,GAAG,CAACD,EAAE,GAAGL,MAAM,CAACO,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGF,EAAE,CAACP,GAAG,CAAC,KAAK,IAAI,GAAGQ,EAAE,GAAGP,YAAY;IAC9F,CAAK,CAAC;EACN,CAAG,MAAM;IACL,OAAOC,MAAM;EACjB;AACA;AACY,MAACQ,mBAAmB,GAAG,CAACR,MAAM,EAAES,GAAG,EAAEC,MAAM,GAAG,KAAK,KAAK;EAClE,IAAIL,EAAE;EACN,MAAMM,OAAO,GAAG,CAAC,CAACV,kBAAkB,EAAE;EACtC,MAAMW,SAAS,GAAGD,OAAO,GAAGd,eAAe,EAAE,GAAG,KAAK,CAAC;EACtD,MAAMgB,SAAS,GAAG,CAACR,EAAE,GAAGI,GAAG,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,GAAG,CAACK,OAAO,KAAK,IAAI,GAAGT,EAAE,GAAGM,OAAO,GAAGG,OAAO,GAAG,KAAK,CAAC;EACrG,IAAI,CAACD,SAAS,EAAE;IACdE,SAAS,CAAC,qBAAqB,EAAE,wDAAwD,CAAC;IAC1F;EACJ;EACE,MAAMC,OAAO,GAAGZ,QAAQ,CAAC,MAAM;IAC7B,MAAMa,GAAG,GAAGC,KAAK,CAAClB,MAAM,CAAC;IACzB,IAAI,EAAEY,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACL,KAAK,CAAC,EACjD,OAAOU,GAAG;IACZ,OAAOE,WAAW,CAACP,SAAS,CAACL,KAAK,EAAEU,GAAG,CAAC;EAC5C,CAAG,CAAC;EACFJ,SAAS,CAACV,wBAAwB,EAAEa,OAAO,CAAC;EAC5C,IAAIN,MAAM,IAAI,CAACf,YAAY,CAACY,KAAK,EAAE;IACjCZ,YAAY,CAACY,KAAK,GAAGS,OAAO,CAACT,KAAK;EACtC;EACE,OAAOS,OAAO;AAChB;AACA,MAAMG,WAAW,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAK;EAC5B,IAAIhB,EAAE;EACN,MAAMiB,IAAI,GAAG,CAAC,mBAAmB,IAAIC,GAAG,CAAC,CAAC,GAAGC,MAAM,CAACJ,CAAC,CAAC,EAAE,GAAGI,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC;EACvE,MAAMI,GAAG,GAAG,EAAE;EACd,KAAK,MAAM3B,GAAG,IAAIwB,IAAI,EAAE;IACtBG,GAAG,CAAC3B,GAAG,CAAC,GAAG,CAACO,EAAE,GAAGgB,CAAC,CAACvB,GAAG,CAAC,KAAK,IAAI,GAAGO,EAAE,GAAGe,CAAC,CAACtB,GAAG,CAAC;EAClD;EACE,OAAO2B,GAAG;AACZ,CAAC","names":["globalConfig","ref","useGlobalConfig","key","defaultValue","config","getCurrentInstance","inject","configProviderContextKey","computed","_a","_b","value","provideGlobalConfig","app","global","inSetup","oldConfig","provideFn","provide","debugWarn","context","cfg","unref","mergeConfig","a","b","keys","Set","keysOf","obj"],"sources":["../../../../../packages/hooks/use-global-config/index.ts"],"sourcesContent":["import { computed, getCurrentInstance, inject, provide, ref, unref } from 'vue'\nimport { configProviderContextKey } from '@element-plus/tokens'\nimport { debugWarn, keysOf } from '@element-plus/utils'\n\nimport type { MaybeRef } from '@vueuse/core'\nimport type { App, Ref } from 'vue'\nimport type { ConfigProviderContext } from '@element-plus/tokens'\n\n// this is meant to fix global methods like `ElMessage(opts)`, this way we can inject current locale\n// into the component as default injection value.\n// refer to: https://github.com/element-plus/element-plus/issues/2610#issuecomment-887965266\nconst globalConfig = ref<ConfigProviderContext>()\n\nexport function useGlobalConfig<\n  K extends keyof ConfigProviderContext,\n  D extends ConfigProviderContext[K]\n>(\n  key: K,\n  defaultValue?: D\n): Ref<Exclude<ConfigProviderContext[K], undefined> | D>\nexport function useGlobalConfig(): Ref<ConfigProviderContext>\nexport function useGlobalConfig(\n  key?: keyof ConfigProviderContext,\n  defaultValue = undefined\n) {\n  const config = getCurrentInstance()\n    ? inject(configProviderContextKey, globalConfig)\n    : globalConfig\n  if (key) {\n    return computed(() => config.value?.[key] ?? defaultValue)\n  } else {\n    return config\n  }\n}\n\nexport const provideGlobalConfig = (\n  config: MaybeRef<ConfigProviderContext>,\n  app?: App,\n  global = false\n) => {\n  const inSetup = !!getCurrentInstance()\n  const oldConfig = inSetup ? useGlobalConfig() : undefined\n\n  const provideFn = app?.provide ?? (inSetup ? provide : undefined)\n  if (!provideFn) {\n    debugWarn(\n      'provideGlobalConfig',\n      'provideGlobalConfig() can only be used inside setup().'\n    )\n    return\n  }\n\n  const context = computed(() => {\n    const cfg = unref(config)\n    if (!oldConfig?.value) return cfg\n    return mergeConfig(oldConfig.value, cfg)\n  })\n  provideFn(configProviderContextKey, context)\n  if (global || !globalConfig.value) {\n    globalConfig.value = context.value\n  }\n  return context\n}\n\nconst mergeConfig = (\n  a: ConfigProviderContext,\n  b: ConfigProviderContext\n): ConfigProviderContext => {\n  const keys = [...new Set([...keysOf(a), ...keysOf(b)])]\n  const obj: Record<string, any> = {}\n  for (const key of keys) {\n    obj[key] = b[key] ?? a[key]\n  }\n  return obj\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}